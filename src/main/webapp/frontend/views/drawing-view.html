<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/paper-fab/paper-fab.html">
<link rel="import" href="../bower_components/paper-swatch-picker/paper-swatch-picker.html">
<link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout-classes.html">


<dom-module id="drawing-view">
    <template>
        <style>

            #container {
                display: flex;
                width: 100%;

            }

            #drawingCanvas {
                visibility: hidden;
                position: absolute;
                top: 0px;
                left: 5%;
                /*right: 5%;*/
                width: 95%;
            }

            #toggle-container {
                width: 5%;
            }

            #chat {

                background: grey;
                width: 20%;

            }

            #content {
                background: greenyellow;
                width: 75%;
            }

            #fabDraw {
                position: fixed;
                left: 10px;
                bottom: 50%;
                background: green;
            }

            #colorpicker {
                position: fixed;
                left: 5px;
                bottom: 42%;
            }

        </style>

        <div id="container">

            <div id="toggle-container">
                <paper-fab mini id="fabDraw" icon="create" label="derp" on-click="toggleCanvas"></paper-fab>

                <paper-swatch-picker id="colorpicker" color="{{selectedColor}}"></paper-swatch-picker>
            </div>

            <canvas id="drawingCanvas"></canvas>

            <div id="chat">
                <span>CHAT</span>
            </div>

            <div id="content">

                <h2>Drawing test:</h2>
                <button on-click="connectWebsocket">Connect</button>
                <br>
                <button on-click="disconnectWebsocket">Disconnect</button>
                <br>
                <button on-click="sendHello">Send Hello</button>
                <br>
                <br>
                <span>(see console)</span>
                <br>
                <br>
                <span id="result"></span>

            </div>
        </div>

    </template>
    <script>
        class DrawingView extends Polymer.Element {
            static get is() {
                return 'drawing-view';
            }

            static get properties() {
                return {
                    selectedColor: {
                        type: String,
                        value: '#E91E63'
                    }
                }
            }

            ready() {
                super.ready();

                //window.addEventListener("mousedown", this);
                this.labelcooldown = false;
                this.pathRepository = [];


                paper.install(this);
                paper.setup(this.$.drawingCanvas);


                let tool = new paper.Tool();
                let currentPath = new paper.Path();

                // Define a mousedown, mousedrag and mouseup handler
                tool.onMouseDown = (event) => {
                    currentPath = new paper.Path();
                    currentPath.strokeColor = this.get('selectedColor');
                    currentPath.strokeWidth = 4;
                    currentPath.add(event.point);
                };

                tool.onMouseDrag = (event) => {
                    currentPath.add(event.point);

                };

                tool.onMouseUp = (event) => {
                    //

                    let currentPathObject = {owner: this.get('userName'), color: this.get('selectedColor'), points: []};
                    //translate point (currentPath.segments.[1]=x & [2]=y) to relative point against screen size: (works with identicle browsers...)
                    let windowWidth = window.innerWidth;
                    let windowHeight = window.innerHeight;
                    currentPath.segments.forEach((data) => {

                        currentPathObject.points.push([data.point.x / windowWidth, data.point.y / windowHeight]);

                    });

                    //add to repo
                    this.pathRepository.push(currentPathObject);
                    //remove last drawn Path from canvas:
                    currentPath.remove();
                    //repaint the hole thing
                    this.repaintPathRepository();
                    //send new Path to Websocket:
                    this.sendPathToWebsocket(currentPathObject);
                };

            }

            repaintPathRepository() {
                //clear everything:
                paper.project.activeLayer.removeChildren();
                //repaint
                let windowWidth = window.innerWidth;
                let windowHeight = window.innerHeight;
                this.pathRepository.forEach((pathObject) => {

                    let path = new paper.Path();
                    //show owner label on hover
                    path.onMouseEnter = (event) => {
                        //check canvas is visible & label not on cooldown:
                        if (this.$.drawingCanvas.style.visibility === 'visible' && !this.labelcooldown) {
                            this.labelcooldown = true;

                            let labelPoint = event.point;
                            labelPoint.x += 20;
                            let labelText = new paper.PointText(labelPoint);
                            labelText.content = pathObject.owner;
                            labelText.style = {
                                fontFamily: 'Courier New',
                                fontWeight: 'bold',
                                fontSize: 14,
                                justification: 'left'
                            };
                            pathObject.labelText = labelText;

                            //label show delay:
                            setTimeout(() => {
                                this.labelcooldown = false;
                            }, 1000); //delay new
                        }
                    };

                    path.onMouseLeave = (event) => {
                        if (this.$.drawingCanvas.style.visibility === 'visible') {
                            setTimeout(() => { //delay removal of label 750 msec.
                                pathObject.labelText.remove();
                            }, 750);
                        }
                    };
                    pathObject.points.forEach((data) => {

                        path.add(new paper.Point(data[0] * windowWidth, data[1] * windowHeight));
                    });
                    path.strokeColor = pathObject.color;
                    path.strokeWidth = 4;
                });
            }

            toggleCanvas() {
                this.$.drawingCanvas.style.visibility = this.$.drawingCanvas.style.visibility === 'visible' ? 'hidden' : 'visible';
                this.$.fabDraw.icon = this.$.fabDraw.icon === "create" ? 'close' : 'create';
                this.$.fabDraw.style.background = this.$.fabDraw.icon === 'create' ? 'green' : 'red';
                //this.$.colorpicker.style.visibility = this.$.colorpicker.style.visibility === 'visible' ? 'hidden' : 'visible';
            }

            connectWebsocket() {
                let socket = new SockJS('/communication');
                this.stompClient = webstomp.over(socket);

                this.stompClient.connect({}, (client) => {
                    console.log('Connected: ' + client);
                    this.stompClient.subscribe('/subscribe/chat', (data) => {
                        console.log("GOT: ", data.body);
                        this.$.result.textContent = data.body;
                    });
                    this.stompClient.subscribe('/subscribe/drawing', (data) => {

                        let pathObject = JSON.parse(data.body);
                        console.log("got", pathObject);
                        this.pathRepository.push(pathObject);
                        this.repaintPathRepository();
                    });
                });
            }

            disconnectWebsocket() {
                if (this.stompClient !== undefined) {
                    this.stompClient.disconnect();
                }
                console.log("Disconnected");
            }

            sendPathToWebsocket(pathObject) {

                if (this.stompClient !== undefined && this.stompClient.connected) {
                    console.log("send path.");
                    this.stompClient.send('/client/drawing', JSON.stringify(pathObject));
                } else {
                    console.log("not connected!");
                }

            }


        }

        window.customElements.define(DrawingView.is, DrawingView);
    </script>
</dom-module>